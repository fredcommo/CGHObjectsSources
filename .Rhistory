return(m)
}
# .pickS <- function(MStable, m){
#   j <- which(MStable$Ml <= m & MStable$Mu > m)
#   if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
#   else {
#     tmpS <- MStable$S[j]
# #    if(length(tmpS)>2){
# #      dS <- density(tmpS, na.rm = TRUE)
# #      s <- sample(dS$x[dS$x>0], 1, replace = FALSE)#, prob = pchisq(dS$x[dS$x>0], df = 1, ncp = m, lower.tail = FALSE))
#       s <- sample(tmpS, 1)#, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
# #    }
# #    else s <- sample(tmpS, 1)
#     }
#   return(s)
# }
.pickS <- function(MStable, m){
j <- which(MStable$Ml <= m & MStable$Mu > m)
#  if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
if(length(j)<1) {s <- min(MStable$S, na.rm = TRUE); cat('min S used for m:', m, '\n')}  else {
tmpS <- MStable$S[j]
if(length(tmpS)>2)
s <- sample(tmpS, 1, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
else s <- sample(tmpS, 1)
}
return(s)
}
.generateRandom <- function(Mvector, Svector, n, p){
# provide a vector of means and a vector of corresponding Sdev
# n samples, p probes
# returns a (p, n) matrix of random probes
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('random', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(output)
}
.generateGrps <- function(Mvector, Svector, n, p, grps = NULL, nGrp = 2, minP = 0.3, maxP = 0.8){
# Provide vector of means and coresspondong Sdev
# n, p : number of samples (provides if grps if not provided), number of probes, resp.
# minP, maxP : min and max proportion of samples in a grp for which a specif probe is generated.
# Returns a (p, n) matrix of probes specific to grps and the vector of grps as a list.
# if grps not provided, generate random grps according to nGrps
if(is.null(grps))
grps <- factor(rbinom(n, nGrp - 1, 0.5), labels = LETTERS[1:nGrp])
else if(!is.factor(grps)) grps <- as.factor(grps)
if(length(grps) != n) n <- length(grps)
nGrps <- nlevels(grps)
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
grp <- sample(levels(grps), 1)
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
# with respect to grps but some samples only, according to minP/maxP
idx <- sample(which(grps == grp))
rbi <- rbinom(length(idx), 1, prob = sample(seq(minP, maxP, by = 0.05), 1))
idx <- idx[rbi == 1]
change <- sample(c('inc', 'dec'), 1)
if(change == 'inc')
newmu <- min(max(MStable$M)*0.95, m*sample(seq(1.5, 2.5, by = 0.2), 1))
else
newmu <- max(min(MStable$M)*1.05, m/sample(seq(1.5, 2.5, by = 0.2), 1))
values[idx] <- rnorm(length(idx), newmu, .pickS(MStable, newmu))
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('signif', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(list(Data = output, Grps = grps))
}
require(splines)
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/pcaSelect.R')
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/pcaInfo.R')
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/pcaTrace.R')
source('/Users/fredcommo/Documents/MyProjects/Fred_Scripts/plotPCA.R')
op <- par(no.readonly = TRUE)
.computeBounds <- function(M, S){
mCuts <- cut(M, breaks = seq(min(M, na.rm = TRUE), max(M, na.rm = TRUE), by = 0.2)) #
labs <- levels(mCuts)
mBounds <- cbind.data.frame(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
mBounds$lower[1] <- min(M, na.rm = TRUE)
mBounds$upper[nrow(mBounds)] <- max(M, na.rm = TRUE)
mBounds <- cbind.data.frame(lower = mBounds$lower, med = (mBounds$upper + mBounds$lower)/2, upper = mBounds$upper)
sBounds <- lapply(seq(1, nrow(mBounds)), function(x){
index <- as.numeric(which(M >= mBounds$lower[x] & M < mBounds$upper[x]))
if(length(index)<1) cbind(S = NA, M = mBounds$med[x], Ml = mBounds$lower[x], Mu = mBounds$upper[x])
else cbind(S = S[index], M = mBounds$med[x], Ml = mBounds$lower[x], Mu = mBounds$upper[x])
})
sBounds <- do.call(rbind, sBounds)
rownames(sBounds) <- seq(1, nrow(sBounds))
return(as.data.frame(sBounds))
}
.dfunc <- function(x){
sbar <- sd(x, na.rm = TRUE)
mbar <- mean(x, na.rm = TRUE)
return(1/(sbar*sqrt(2*pi))*exp(-1/2*((x-mbar)/sbar)^2))
}
.pickM <- function(dM){
m = as.numeric(sample(dM$x, 1, prob = dM$y))
return(m)
}
# .pickS <- function(MStable, m){
#   j <- which(MStable$Ml <= m & MStable$Mu > m)
#   if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
#   else {
#     tmpS <- MStable$S[j]
# #    if(length(tmpS)>2){
# #      dS <- density(tmpS, na.rm = TRUE)
# #      s <- sample(dS$x[dS$x>0], 1, replace = FALSE)#, prob = pchisq(dS$x[dS$x>0], df = 1, ncp = m, lower.tail = FALSE))
#       s <- sample(tmpS, 1)#, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
# #    }
# #    else s <- sample(tmpS, 1)
#     }
#   return(s)
# }
.pickS <- function(MStable, m){
j <- which(MStable$Ml <= m & MStable$Mu > m)
#  if(length(j)<1) {s <- min(dS$x, na.rm = TRUE); cat('min S used for m:', m, '\n')}
if(length(j)<1) {s <- min(MStable$S, na.rm = TRUE); cat('min S used for m:', m, '\n')}  else {
tmpS <- MStable$S[j]
if(length(tmpS)>2)
s <- sample(tmpS, 1, prob = pchisq(tmpS, df = 1, ncp = m, lower.tail = FALSE))
else s <- sample(tmpS, 1)
}
return(s)
}
.generateRandom <- function(Mvector, Svector, n, p){
# provide a vector of means and a vector of corresponding Sdev
# n samples, p probes
# returns a (p, n) matrix of random probes
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('random', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(output)
}
.generateGrps <- function(Mvector, Svector, n, p, grps = NULL, nGrp = 2, minP = 0.3, maxP = 0.8){
# Provide vector of means and coresspondong Sdev
# n, p : number of samples (provides if grps if not provided), number of probes, resp.
# minP, maxP : min and max proportion of samples in a grp for which a specif probe is generated.
# Returns a (p, n) matrix of probes specific to grps and the vector of grps as a list.
# if grps not provided, generate random grps according to nGrps
if(is.null(grps))
grps <- factor(rbinom(n, nGrp - 1, 0.5), labels = LETTERS[1:nGrp])
else if(!is.factor(grps)) grps <- as.factor(grps)
if(length(grps) != n) n <- length(grps)
nGrps <- nlevels(grps)
dM <- density(Mvector)
MStable <- .computeBounds(Mvector, Svector)
output <- lapply(seq(1, p),
function(x){ if(x%%ceiling(p/10) == 0) cat(x, '\t')
m <- max(min(MStable$M),.pickM(dM))
if(is.na(m)) stop('m is NA')
grp <- sample(levels(grps), 1)
s <- .pickS(MStable, m)
values <- rnorm(n, m, s)
# with respect to grps but some samples only, according to minP/maxP
idx <- sample(which(grps == grp))
rbi <- rbinom(length(idx), 1, prob = sample(seq(minP, maxP, by = 0.05), 1))
idx <- idx[rbi == 1]
change <- sample(c('inc', 'dec'), 1)
if(change == 'inc')
newmu <- min(max(MStable$M)*0.95, m*sample(seq(1.5, 2.5, by = 0.2), 1))
else
newmu <- max(min(MStable$M)*1.05, m/sample(seq(1.5, 2.5, by = 0.2), 1))
values[idx] <- rnorm(length(idx), newmu, .pickS(MStable, newmu))
if(any(is.na(values))) stop('s', s, 'is NA for m:', m)
return(values)
})
output <- do.call(rbind, output)
rownames(output) <- paste0('signif', seq(1, nrow(output)))
colnames(output) <- paste0('sample', seq(1, ncol(output)))
return(list(Data = output, Grps = grps))
}
kimData = readRDS('/Users/fredcommo/Documents/MyProjects/Kim_Lung/kimData.rds')
eset = kimData$eset
samples <- kimData$samples
M <- apply(eset, 1, mean, na.rm = TRUE)
S <- apply(eset, 1, sd, na.rm = TRUE)
trueDist <- .computeBounds(M, S)
factM <- factor(trueDist$M)
whiteProbes <- lapply(seq(1, 2500), function(x){ if(x%%100 == 0) cat(x, '\t')
x <- sample(eset[sample(1, nrow(eset), 1),])
})
x <- eset[sample(1, nrow(eset), 1),]
sample(x, replace = TRUE)
x
x <- as.numeric(eset[sample(1, nrow(eset), 1),])
x <- as.numeric(eset[sample(1:nrow(eset), 1),])
x
sample(x, replace = TRUE)
whiteProbes <- lapply(seq(1, 100), function(x){ if(x%%100 == 0) cat(x, '\t')
x <- as.numeric(eset[sample(1:nrow(eset), 1),])
return(sample(x, replace = TRUE))
})
Samp <- sample(1:nrow(eset), 1000)
Samp <- sample(1:nrow(eset), 1000)
whiteProbes <- lapply(Samp, function(x){ if(x%%100 == 0) cat(x, '\t')
return(sample(as.numeric(eset[x,]), replace = TRUE))
})
Samp <- sample(1:nrow(eset), 2500)
whiteProbes <- lapply(Samp, function(x){return(sample(as.numeric(eset[x,]), replace = TRUE))})
whiteProbes <- do.call(rbind, whiteProbes)
rownames(whiteProbes) <- paste0('random', seq(1, nrow(whiteProbes)))
whiteM <- apply(whiteProbes, 1, mean, na.rm = TRUE)
whiteS <- apply(whiteProbes, 1, sd, na.rm = TRUE)
whiteProbesTable <- .computeBounds(whiteM, whiteS)
boxplot(log10(whiteProbesTable$S) ~ whiteProbesTable$M, names = round(unique(whiteProbesTable$M), 2),
outpch = 19, outcex = 0.25, col = 'steelblue2', outcol = 'steelblue4',
xlab = 'Means', ylab = 'Log10(Sdev)')
boxplot(log10(whiteProbesTable$S) ~ whiteProbesTable$M,
outpch = 19, outcex = 0.25, col = 'steelblue2', outcol = 'steelblue4',
xlab = 'Means', ylab = 'Log10(Sdev)')
head(samples)
q()
projectId <- "syn1834040"
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
fileHandleId <- file@fileHandle$id
fileWikiUri <- sprintf("/entity/%s/wiki", propertyValue(file, "id"))
require(synapseClient)
synapseLogin('frederic.commo@sagebase.org', 'Se@ttle7')
projectId <- "syn1834040"
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
file
properties(getEntity(projectId))
file <- synStore(file)
file <- storeEntity(file)
projectId <- "syn1834037"
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
file
file <- storeEntity(file)
e <- getEntity('syn1834040')
e@fileHandle$id
file <- storeEntity(file)
traceback()
file<-synStore(file)
traceback()
rm(file)
# note, we recommend using "File" rather than "Data"
myPath <- '/Users/fredcommo/Documents/MyProjects/Projet ACP/Some_TCGA/'
myImage <- "unc.edu_BLCA_IlluminaHiSeq_RNASeqV2.geneExp.whitelist_tumor_syn1571504_PCAfilt_2.png"
file <- File(paste0(myPath, myImage), parentId=projectId)
file <- synStore(file)
fileHandleId <- file@fileHandle$id
fileWikiUri <- sprintf("/entity/%s/wiki", propertyValue(file, "id"))
# we start a wiki
fileWiki<-list()
# we add to our wiki the ID of the previously uploaded file
fileWiki$attachmentFileHandleIds<-list(fileHandleId)
# in the markdown we say to display the image.  Note, 'fileName' is the URLEncoded version of the file chosen above.
fileWiki$markdown<-"${image?fileName=mygraph%2Epng}"
# now 'push' the wiki to Synapse
fileWiki<-synRestPOST(fileWikiUri, fileWiki)
# voila!
onWeb(propertyValue(file, "id"))
require(synapseClient)
require(affy)
synapseLogin()
q()
source('http://depot.sagebase.org/CRAN.R')
pkgInstall("synapseClient")
q()
require(synapseClient)
synapseLogin()
e <- loadEntity('syn1855802')
source(file.path(e$cacheDir, e$files))
e <- loadEntity('syn1855799')
load(file.path(e$cacheDir, e$files))
sangerCells
ge <- getExprs(sangerCells)
ge[1:10, 1:5]
cellList <- getCells(sangerCells)
head(cellList)
sangerCells
require(synapseClient)
synapseLogin()
require(synapseClient)
synapseLogin()
# Test Affy workflow
scriptPath = "/Users/fredcommo/Documents/Projet Safir/Safir R Sources/CGHObjects/"
setwd(scriptPath)
source('SourceCodeObj.R')
cgh  <- loadEntity('syn1864342')
load(file.path(cgh$cacheDir, cgh$files))
e <- downloadEntity('syn1864121')
e
e$attachments
e$properties
e$attachDir
e$available.versions
e@attachOwn
e@annotations
e@synapseEntityKind
e@synapseWebUrl
.getWiki <- function(synId){
uri <- paste0("/entity/%s/wiki/", synId)
synRestGET(folderWikiUri)
}
wiki <- .getWiki('1864121')
# Convert a data.frame into markdown
.getWiki <- function(synId){
uri <- paste0("/entity/%s/wiki/", synId)
synRestGET(uri)
}
wiki <- .getWiki('1864121')
# Convert a data.frame into markdown
.getWiki <- function(synId){
uri <- sprintf("/entity/%s/wiki/", synId)
synRestGET(uri)
}
wiki <- .getWiki('1864121')
wiki
.getWiki <- function(synId){
synRestGET(sprintf("/entity/%s/wiki/", synId))
}
wiki <- .getWiki('1864121')
wiki
wiki <- .getWiki('syn1864121')
wiki
wiki <- .getWiki('1864121')
wiki <- .getWiki('1864121')
# create a list of symbols
geneList = c("CCND1", "ALK", "MDM2", "FRS2", "MET", "RPTOR", "ESR1", "PGR", "FGFR1", "FGFR2",
"MYC", "FGF4", "FGF9", "EGFR", "ERBB2", "TOP2A", "IGF1", "IGF1R", "BRCA1", "BRCA2",
"NOTCH4", "VEGFA", "PTEN", "PIK3CB", "PAK1")
# retrieve the annotations
geneTable <- geneOfInt(cghProfile, geneList)
convert2mkd <- function(myTab, headers = TRUE){
output = ''
if (headers){
#    head.sep = ''
foreach(n = iter(names(myTab))) %do% {
output = paste(output, n, sep = '|')
#     head.sep = paste(head.sep, '-', sep = '|')
}
output = paste0(output, '\n')
}
for (r in 1:nrow(myTab)){
tmp <- myTab[r,]
foreach(s=iter(tmp)) %do% {output = paste(output, s, sep = '|')}
output = paste0(output, '\n')
}
return(output)
}
ncbiLink <- function(symbol, id){
link <- paste0('[', symbol, ']', '(http://www.ncbi.nlm.nih.gov/gene?term=', id,'[UID])')
return(link)
}
Table <- cbind.data.frame(Symbol = ncbiLink(geneTable$Symbol, geneTable$entrezgene),
Alias = gsub(' ', '', geneTable$Alias),
Cytoband = geneTable$Cytoband,
Log2Ratio = geneTable$Log2Ratio)
convert2mkd(Table[1:2,])
paste0(names(Table), collapse='|')
paste0(Table[1,], collapse='|')
Table[1,]
paste0(as.character(Table[1,]), collapse='|')
paste0(as.vector(Table[1,]), collapse='|')
as.vector(Table[1,])
x <- as.character(as.vector(Table[1,]))
x
x <- as.vector(Table[1,])
x
paste0(x, collapse='|')
paste0(c(x), collapse='|')
x <- as.character(Table[1,])
x
x <- as.vector(Table[1,])
x <- gettext(Table[1,])
x
x <- text(Table[1,])
x <- as.names(Table[1,])
x <- names(Table[1,])
x
?gettext
x <- xgettext(Table[1,])
x <- cat(Table[1,])
x <- sprintf(Table[1,])
x <- Table[1,]
x
x <- as.vector(Table[1,])
x
x <- as.matrix(Table[1,])
x
x <- as.character((as.matrix(Table[1,]))
x <- as.character(as.matrix(Table[1,]))
x
paste0(x, collapse='|')
paste0(as.matrix(Table[1,]), collapse='|')
Table <- cbind.data.frame(Symbol = ncbiLink(geneTable$Symbol, geneTable$entrezgene),
Alias = gsub(' ', '', geneTable$Alias),
Cytoband = geneTable$Cytoband,
Log2Ratio = round(geneTable$Log2Ratio), 3)
convert2mkd <- function(myTab, headers = TRUE){
output <- lapply(1:nrow(myTab), function(i){paste0(paste0(as.matrix(myTab[i,]), collapse='|'),'\n')})
output <- do.call(paste0, output)
if (headers){
Head <- paste0(paste0(names(Table), collapse='|'), '\n')
output <- paste0(Head, output)
}
return(output)
}
convert2mkd(Table[1:2,])
head(geneTable)
Table <- cbind.data.frame(Symbol = ncbiLink(geneTable$Symbol, geneTable$entrezgene),
Alias = gsub(' ', '', geneTable$Alias),
Description = geneTable$Description,
Chr = geneTable$Chr,
Cytoband = geneTable$Cytoband,
Log2Ratio = round(geneTable$Log2Ratio), 3)
convert2mkd(Table)
wiki
mkd <- strplit(wiki$markdown, '\n')
mkd <- strsplit(wiki$markdown, '\n')
mkd
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd
length(mkd)
paste0(mkd[1:2], collapse='\n')
paste0(mkd[1:3], convert2mkd(Table), mkd[-c(1:3)], collapse='\n')
paste0(mkd[1:3], convert2mkd(Table), mkd[-c(1:6)], collapse='\n')
mkd[1:3]
mkd <- paste0(mkd[1:3], convert2mkd(Table), mkd[-c(1:6)], collapse='\n')
unlist(strsplit(mkd, '\n'))
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd
paste0(mkd, collapse='\n')
Table <- cbind.data.frame(Symbol = ncbiLink(geneTable$Symbol, geneTable$entrezgene),
Alias = gsub(' ', '', geneTable$Alias),
Description = geneTable$Description,
Chr = geneTable$Chr,
Cytoband = geneTable$Cytoband,
Log2Ratio = round(geneTable$Log2Ratio), 3)
Table
convert2mkd(Table)
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd <- paste(mkd[1:3], convert2mkd(Table), collapse='\n')
mkd
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd <- paste(paste0(mkd[1:3], collapse='\n'), convert2mkd(Table), collapse='\n')
mkd
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd <- paste(paste0(mkd[1:3], collapse='\n'), convert2mkd(Table), collapse='\n')
mkd <- paste(mkd, paste0(mkd[-c(1:6)], collapse='\n'), collapse='\n')
unlist(strsplit(mkd, '\n'))
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd <- paste(paste0(mkd[1:3], collapse='\n'), convert2mkd(Table), paste0(mkd[-c(1:6)], collapse='\n'),collapse='\n')
unlist(strsplit(mkd, '\n'))
wiki$markdown <- mkd
wiki
wiki$etag
sprintf("/entity/%s/wiki/", 'syn1864121')
wiki <- synRestPUT(sprintf("/entity/%s/wiki/", 'syn1864121'), wiki)
wiki <- synRestPOST(sprintf("/entity/%s/wiki/", 'syn1864121'), wiki)
wiki <- synRestPUT(sprintf("/entity/%s/wiki/", 'syn1864121'), wiki)
uri <- sprintf("/entity/%s/wiki/", synId)
wiki <- synRestGET(uri)
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd <- paste(paste0(mkd[1:3], collapse='\n'), convert2mkd(Table), paste0(mkd[-c(1:6)], collapse='\n'),collapse='\n')
mkd <- paste(mkd, paste0(mkd[-c(1:6)], collapse='\n'), collapse='\n')
# Replace old markdown
wiki$markdown <- mkd
wiki <- synRestPUT(sprintf("/entity/%s/wiki/", 'syn1864121'), wiki)
uri <- sprintf("/entity/%s/wiki/", synId)
wiki <- synRestGET(uri)
synId <- 'syn1864121'
uri <- sprintf("/entity/%s/wiki/", synId)
wiki <- synRestGET(uri)
mkd <- unlist(strsplit(wiki$markdown, '\n'))
mkd <- paste(paste0(mkd[1:3], collapse='\n'), convert2mkd(Table), paste0(mkd[-c(1:6)], collapse='\n'),collapse='\n')
mkd <- paste(mkd, paste0(mkd[-c(1:6)], collapse='\n'), collapse='\n')
# Replace old markdown
wiki$markdown <- mkd
wiki <- synRestPUT(sprintf("/entity/%s/wiki/", synId), wiki)
